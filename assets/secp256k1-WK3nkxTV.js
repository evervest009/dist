import{ae as re,af as oe,ag as ie}from"./index-BNnEztJx.js";import{h as se}from"./hmac-BhKMtS3b.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const yt=BigInt(0),bt=BigInt(1),fe=BigInt(2);function nt(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function gt(e){if(!nt(e))throw new Error("Uint8Array expected")}function ft(e,n){if(typeof n!="boolean")throw new Error(e+" boolean expected, got "+n)}const ce=Array.from({length:256},(e,n)=>n.toString(16).padStart(2,"0"));function ct(e){gt(e);let n="";for(let t=0;t<e.length;t++)n+=ce[e[t]];return n}function st(e){const n=e.toString(16);return n.length&1?"0"+n:n}function Rt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?yt:BigInt("0x"+e)}const $={_0:48,_9:57,A:65,F:70,a:97,f:102};function Ct(e){if(e>=$._0&&e<=$._9)return e-$._0;if(e>=$.A&&e<=$.F)return e-($.A-10);if(e>=$.a&&e<=$.f)return e-($.a-10)}function at(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const n=e.length,t=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(t);for(let i=0,s=0;i<t;i++,s+=2){const a=Ct(e.charCodeAt(s)),c=Ct(e.charCodeAt(s+1));if(a===void 0||c===void 0){const o=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+s)}r[i]=a*16+c}return r}function tt(e){return Rt(ct(e))}function Ut(e){return gt(e),Rt(ct(Uint8Array.from(e).reverse()))}function ut(e,n){return at(e.toString(16).padStart(n*2,"0"))}function _t(e,n){return ut(e,n).reverse()}function ae(e){return at(st(e))}function P(e,n,t){let r;if(typeof n=="string")try{r=at(n)}catch(s){throw new Error(e+" must be hex string or Uint8Array, cause: "+s)}else if(nt(n))r=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");const i=r.length;if(typeof t=="number"&&i!==t)throw new Error(e+" of length "+t+" expected, got "+i);return r}function wt(...e){let n=0;for(let r=0;r<e.length;r++){const i=e[r];gt(i),n+=i.length}const t=new Uint8Array(n);for(let r=0,i=0;r<e.length;r++){const s=e[r];t.set(s,i),i+=s.length}return t}function ue(e,n){if(e.length!==n.length)return!1;let t=0;for(let r=0;r<e.length;r++)t|=e[r]^n[r];return t===0}function le(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}const xt=e=>typeof e=="bigint"&&yt<=e;function Et(e,n,t){return xt(e)&&xt(n)&&xt(t)&&n<=e&&e<t}function et(e,n,t,r){if(!Et(n,t,r))throw new Error("expected valid "+e+": "+t+" <= n < "+r+", got "+n)}function $t(e){let n;for(n=0;e>yt;e>>=bt,n+=1);return n}function de(e,n){return e>>BigInt(n)&bt}function he(e,n,t){return e|(t?bt:yt)<<BigInt(n)}const kt=e=>(fe<<BigInt(e-1))-bt,St=e=>new Uint8Array(e),Vt=e=>Uint8Array.from(e);function Gt(e,n,t){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=St(e),i=St(e),s=0;const a=()=>{r.fill(1),i.fill(0),s=0},c=(...I)=>t(i,r,...I),o=(I=St())=>{i=c(Vt([0]),I),r=c(),I.length!==0&&(i=c(Vt([1]),I),r=c())},u=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let I=0;const d=[];for(;I<n;){r=c();const v=r.slice();d.push(v),I+=r.length}return wt(...d)};return(I,d)=>{a(),o(I);let v;for(;!(v=d(u()));)o();return a(),v}}const we={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||nt(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,n)=>n.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function mt(e,n,t={}){const r=(i,s,a)=>{const c=we[s];if(typeof c!="function")throw new Error("invalid validator function");const o=e[i];if(!(a&&o===void 0)&&!c(o,e))throw new Error("param "+String(i)+" is invalid. Expected "+s+", got "+o)};for(const[i,s]of Object.entries(n))r(i,s,!1);for(const[i,s]of Object.entries(t))r(i,s,!0);return e}const ge=()=>{throw new Error("not implemented")};function Ot(e){const n=new WeakMap;return(t,...r)=>{const i=n.get(t);if(i!==void 0)return i;const s=e(t,...r);return n.set(t,s),s}}const me=Object.freeze(Object.defineProperty({__proto__:null,aInRange:et,abool:ft,abytes:gt,bitGet:de,bitLen:$t,bitMask:kt,bitSet:he,bytesToHex:ct,bytesToNumberBE:tt,bytesToNumberLE:Ut,concatBytes:wt,createHmacDrbg:Gt,ensureBytes:P,equalBytes:ue,hexToBytes:at,hexToNumber:Rt,inRange:Et,isBytes:nt,memoized:Ot,notImplemented:ge,numberToBytesBE:ut,numberToBytesLE:_t,numberToHexUnpadded:st,numberToVarBytesBE:ae,utf8ToBytes:le,validateObject:mt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _=BigInt(0),L=BigInt(1),J=BigInt(2),pe=BigInt(3),Tt=BigInt(4),Mt=BigInt(5),jt=BigInt(8);function j(e,n){const t=e%n;return t>=_?t:n+t}function ye(e,n,t){if(n<_)throw new Error("invalid exponent, negatives unsupported");if(t<=_)throw new Error("invalid modulus");if(t===L)return _;let r=L;for(;n>_;)n&L&&(r=r*e%t),e=e*e%t,n>>=L;return r}function H(e,n,t){let r=e;for(;n-- >_;)r*=r,r%=t;return r}function zt(e,n){if(e===_)throw new Error("invert: expected non-zero number");if(n<=_)throw new Error("invert: expected positive modulus, got "+n);let t=j(e,n),r=n,i=_,s=L;for(;t!==_;){const c=r/t,o=r%t,u=i-s*c;r=t,t=o,i=s,s=u}if(r!==L)throw new Error("invert: does not exist");return j(i,n)}function be(e){const n=(e-L)/J;let t,r,i;for(t=e-L,r=0;t%J===_;t/=J,r++);for(i=J;i<e&&ye(i,n,e)!==e-L;i++)if(i>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const a=(e+L)/Tt;return function(o,u){const E=o.pow(u,a);if(!o.eql(o.sqr(E),u))throw new Error("Cannot find square root");return E}}const s=(t+L)/J;return function(c,o){if(c.pow(o,n)===c.neg(c.ONE))throw new Error("Cannot find square root");let u=r,E=c.pow(c.mul(c.ONE,i),t),I=c.pow(o,s),d=c.pow(o,t);for(;!c.eql(d,c.ONE);){if(c.eql(d,c.ZERO))return c.ZERO;let v=1;for(let m=c.sqr(d);v<u&&!c.eql(m,c.ONE);v++)m=c.sqr(m);const N=c.pow(E,L<<BigInt(u-v-1));E=c.sqr(N),I=c.mul(I,N),d=c.mul(d,E),u=v}return I}}function Ee(e){if(e%Tt===pe){const n=(e+L)/Tt;return function(r,i){const s=r.pow(i,n);if(!r.eql(r.sqr(s),i))throw new Error("Cannot find square root");return s}}if(e%jt===Mt){const n=(e-Mt)/jt;return function(r,i){const s=r.mul(i,J),a=r.pow(s,n),c=r.mul(i,a),o=r.mul(r.mul(c,J),a),u=r.mul(c,r.sub(o,r.ONE));if(!r.eql(r.sqr(u),i))throw new Error("Cannot find square root");return u}}return be(e)}const Be=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ve(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Be.reduce((r,i)=>(r[i]="function",r),n);return mt(e,t)}function xe(e,n,t){if(t<_)throw new Error("invalid exponent, negatives unsupported");if(t===_)return e.ONE;if(t===L)return n;let r=e.ONE,i=n;for(;t>_;)t&L&&(r=e.mul(r,i)),i=e.sqr(i),t>>=L;return r}function Se(e,n){const t=new Array(n.length),r=n.reduce((s,a,c)=>e.is0(a)?s:(t[c]=s,e.mul(s,a)),e.ONE),i=e.inv(r);return n.reduceRight((s,a,c)=>e.is0(a)?s:(t[c]=e.mul(s,t[c]),e.mul(s,a)),i),t}function Wt(e,n){const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Xt(e,n,t=!1,r={}){if(e<=_)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:i,nByteLength:s}=Wt(e,n);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const c=Object.freeze({ORDER:e,isLE:t,BITS:i,BYTES:s,MASK:kt(i),ZERO:_,ONE:L,create:o=>j(o,e),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return _<=o&&o<e},is0:o=>o===_,isOdd:o=>(o&L)===L,neg:o=>j(-o,e),eql:(o,u)=>o===u,sqr:o=>j(o*o,e),add:(o,u)=>j(o+u,e),sub:(o,u)=>j(o-u,e),mul:(o,u)=>j(o*u,e),pow:(o,u)=>xe(c,o,u),div:(o,u)=>j(o*zt(u,e),e),sqrN:o=>o*o,addN:(o,u)=>o+u,subN:(o,u)=>o-u,mulN:(o,u)=>o*u,inv:o=>zt(o,e),sqrt:r.sqrt||(o=>(a||(a=Ee(e)),a(c,o))),invertBatch:o=>Se(c,o),cmov:(o,u,E)=>E?u:o,toBytes:o=>t?_t(o,s):ut(o,s),fromBytes:o=>{if(o.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+o.length);return t?Ut(o):tt(o)}});return Object.freeze(c)}function Dt(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function Qt(e){const n=Dt(e);return n+Math.ceil(n/2)}function Ae(e,n,t=!1){const r=e.length,i=Dt(n),s=Qt(n);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const a=t?Ut(e):tt(e),c=j(a,n-L)+L;return t?_t(c,i):ut(c,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Yt=BigInt(0),pt=BigInt(1);function At(e,n){const t=n.negate();return e?t:n}function Jt(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function It(e,n){Jt(e,n);const t=Math.ceil(n/e)+1,r=2**(e-1);return{windows:t,windowSize:r}}function Ie(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function qe(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}const qt=new WeakMap,te=new WeakMap;function Nt(e){return te.get(e)||1}function Ne(e,n){return{constTimeNegate:At,hasPrecomputes(t){return Nt(t)!==1},unsafeLadder(t,r,i=e.ZERO){let s=t;for(;r>Yt;)r&pt&&(i=i.add(s)),s=s.double(),r>>=pt;return i},precomputeWindow(t,r){const{windows:i,windowSize:s}=It(r,n),a=[];let c=t,o=c;for(let u=0;u<i;u++){o=c,a.push(o);for(let E=1;E<s;E++)o=o.add(c),a.push(o);c=o.double()}return a},wNAF(t,r,i){const{windows:s,windowSize:a}=It(t,n);let c=e.ZERO,o=e.BASE;const u=BigInt(2**t-1),E=2**t,I=BigInt(t);for(let d=0;d<s;d++){const v=d*a;let N=Number(i&u);i>>=I,N>a&&(N-=E,i+=pt);const m=v,f=v+Math.abs(N)-1,h=d%2!==0,p=N<0;N===0?o=o.add(At(h,r[m])):c=c.add(At(p,r[f]))}return{p:c,f:o}},wNAFUnsafe(t,r,i,s=e.ZERO){const{windows:a,windowSize:c}=It(t,n),o=BigInt(2**t-1),u=2**t,E=BigInt(t);for(let I=0;I<a;I++){const d=I*c;if(i===Yt)break;let v=Number(i&o);if(i>>=E,v>c&&(v-=u,i+=pt),v===0)continue;let N=r[d+Math.abs(v)-1];v<0&&(N=N.negate()),s=s.add(N)}return s},getPrecomputes(t,r,i){let s=qt.get(r);return s||(s=this.precomputeWindow(r,t),t!==1&&qt.set(r,i(s))),s},wNAFCached(t,r,i){const s=Nt(t);return this.wNAF(s,this.getPrecomputes(s,t,i),r)},wNAFCachedUnsafe(t,r,i,s){const a=Nt(t);return a===1?this.unsafeLadder(t,r,s):this.wNAFUnsafe(a,this.getPrecomputes(a,t,i),r,s)},setWindowSize(t,r){Jt(r,n),te.set(t,r),qt.delete(t)}}}function Oe(e,n,t,r){if(Ie(t,e),qe(r,n),t.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const i=e.ZERO,s=$t(BigInt(t.length)),a=s>12?s-3:s>4?s-2:s?2:1,c=(1<<a)-1,o=new Array(c+1).fill(i),u=Math.floor((n.BITS-1)/a)*a;let E=i;for(let I=u;I>=0;I-=a){o.fill(i);for(let v=0;v<r.length;v++){const N=r[v],m=Number(N>>BigInt(I)&BigInt(c));o[m]=o[m].add(t[v])}let d=i;for(let v=o.length-1,N=i;v>0;v--)N=N.add(o[v]),d=d.add(N);if(E=E.add(d),I!==0)for(let v=0;v<a;v++)E=E.double()}return E}function ee(e){return ve(e.Fp),mt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Wt(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ht(e){e.lowS!==void 0&&ft("lowS",e.lowS),e.prehash!==void 0&&ft("prehash",e.prehash)}function Te(e){const n=ee(e);mt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:i}=n;if(t){if(!r.eql(i,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:ze,hexToBytes:Ze}=me;class Le extends Error{constructor(n=""){super(n)}}const G={Err:Le,_tlv:{encode:(e,n)=>{const{Err:t}=G;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const r=n.length/2,i=st(r);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const s=r>127?st(i.length/2|128):"";return st(e)+s+i+n},decode(e,n){const{Err:t}=G;let r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");const i=n[r++],s=!!(i&128);let a=0;if(!s)a=i;else{const o=i&127;if(!o)throw new t("tlv.decode(long): indefinite length not supported");if(o>4)throw new t("tlv.decode(long): byte length is too big");const u=n.subarray(r,r+o);if(u.length!==o)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const E of u)a=a<<8|E;if(r+=o,a<128)throw new t("tlv.decode(long): not minimal encoding")}const c=n.subarray(r,r+a);if(c.length!==a)throw new t("tlv.decode: wrong value length");return{v:c,l:n.subarray(r+a)}}},_int:{encode(e){const{Err:n}=G;if(e<W)throw new n("integer: negative integers are not allowed");let t=st(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=G;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return ze(e)}},toSig(e){const{Err:n,_int:t,_tlv:r}=G,i=typeof e=="string"?Ze(e):e;gt(i);const{v:s,l:a}=r.decode(48,i);if(a.length)throw new n("invalid signature: left bytes after parsing");const{v:c,l:o}=r.decode(2,s),{v:u,l:E}=r.decode(2,o);if(E.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(c),s:t.decode(u)}},hexFromSig(e){const{_tlv:n,_int:t}=G,r=n.encode(2,t.encode(e.r)),i=n.encode(2,t.encode(e.s)),s=r+i;return n.encode(48,s)}},W=BigInt(0),U=BigInt(1);BigInt(2);const Kt=BigInt(3);BigInt(4);function Re(e){const n=Te(e),{Fp:t}=n,r=Xt(n.n,n.nBitLength),i=n.toBytes||((m,f,h)=>{const p=f.toAffine();return wt(Uint8Array.from([4]),t.toBytes(p.x),t.toBytes(p.y))}),s=n.fromBytes||(m=>{const f=m.subarray(1),h=t.fromBytes(f.subarray(0,t.BYTES)),p=t.fromBytes(f.subarray(t.BYTES,2*t.BYTES));return{x:h,y:p}});function a(m){const{a:f,b:h}=n,p=t.sqr(m),y=t.mul(p,m);return t.add(t.add(y,t.mul(m,f)),h)}if(!t.eql(t.sqr(n.Gy),a(n.Gx)))throw new Error("bad generator point: equation left != right");function c(m){return Et(m,U,n.n)}function o(m){const{allowedPrivateKeyLengths:f,nByteLength:h,wrapPrivateKey:p,n:y}=n;if(f&&typeof m!="bigint"){if(nt(m)&&(m=ct(m)),typeof m!="string"||!f.includes(m.length))throw new Error("invalid private key");m=m.padStart(h*2,"0")}let q;try{q=typeof m=="bigint"?m:tt(P("private key",m,h))}catch{throw new Error("invalid private key, expected hex or "+h+" bytes, got "+typeof m)}return p&&(q=j(q,y)),et("private key",q,U,y),q}function u(m){if(!(m instanceof d))throw new Error("ProjectivePoint expected")}const E=Ot((m,f)=>{const{px:h,py:p,pz:y}=m;if(t.eql(y,t.ONE))return{x:h,y:p};const q=m.is0();f==null&&(f=q?t.ONE:t.inv(y));const T=t.mul(h,f),A=t.mul(p,f),b=t.mul(y,f);if(q)return{x:t.ZERO,y:t.ZERO};if(!t.eql(b,t.ONE))throw new Error("invZ was invalid");return{x:T,y:A}}),I=Ot(m=>{if(m.is0()){if(n.allowInfinityPoint&&!t.is0(m.py))return;throw new Error("bad point: ZERO")}const{x:f,y:h}=m.toAffine();if(!t.isValid(f)||!t.isValid(h))throw new Error("bad point: x or y not FE");const p=t.sqr(h),y=a(f);if(!t.eql(p,y))throw new Error("bad point: equation left != right");if(!m.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class d{constructor(f,h,p){if(this.px=f,this.py=h,this.pz=p,f==null||!t.isValid(f))throw new Error("x required");if(h==null||!t.isValid(h))throw new Error("y required");if(p==null||!t.isValid(p))throw new Error("z required");Object.freeze(this)}static fromAffine(f){const{x:h,y:p}=f||{};if(!f||!t.isValid(h)||!t.isValid(p))throw new Error("invalid affine point");if(f instanceof d)throw new Error("projective point not allowed");const y=q=>t.eql(q,t.ZERO);return y(h)&&y(p)?d.ZERO:new d(h,p,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){const h=t.invertBatch(f.map(p=>p.pz));return f.map((p,y)=>p.toAffine(h[y])).map(d.fromAffine)}static fromHex(f){const h=d.fromAffine(s(P("pointHex",f)));return h.assertValidity(),h}static fromPrivateKey(f){return d.BASE.multiply(o(f))}static msm(f,h){return Oe(d,r,f,h)}_setWindowSize(f){N.setWindowSize(this,f)}assertValidity(){I(this)}hasEvenY(){const{y:f}=this.toAffine();if(t.isOdd)return!t.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){u(f);const{px:h,py:p,pz:y}=this,{px:q,py:T,pz:A}=f,b=t.eql(t.mul(h,A),t.mul(q,y)),S=t.eql(t.mul(p,A),t.mul(T,y));return b&&S}negate(){return new d(this.px,t.neg(this.py),this.pz)}double(){const{a:f,b:h}=n,p=t.mul(h,Kt),{px:y,py:q,pz:T}=this;let A=t.ZERO,b=t.ZERO,S=t.ZERO,B=t.mul(y,y),k=t.mul(q,q),Z=t.mul(T,T),z=t.mul(y,q);return z=t.add(z,z),S=t.mul(y,T),S=t.add(S,S),A=t.mul(f,S),b=t.mul(p,Z),b=t.add(A,b),A=t.sub(k,b),b=t.add(k,b),b=t.mul(A,b),A=t.mul(z,A),S=t.mul(p,S),Z=t.mul(f,Z),z=t.sub(B,Z),z=t.mul(f,z),z=t.add(z,S),S=t.add(B,B),B=t.add(S,B),B=t.add(B,Z),B=t.mul(B,z),b=t.add(b,B),Z=t.mul(q,T),Z=t.add(Z,Z),B=t.mul(Z,z),A=t.sub(A,B),S=t.mul(Z,k),S=t.add(S,S),S=t.add(S,S),new d(A,b,S)}add(f){u(f);const{px:h,py:p,pz:y}=this,{px:q,py:T,pz:A}=f;let b=t.ZERO,S=t.ZERO,B=t.ZERO;const k=n.a,Z=t.mul(n.b,Kt);let z=t.mul(h,q),Y=t.mul(p,T),l=t.mul(y,A),w=t.add(h,p),g=t.add(q,T);w=t.mul(w,g),g=t.add(z,Y),w=t.sub(w,g),g=t.add(h,y);let x=t.add(q,A);return g=t.mul(g,x),x=t.add(z,l),g=t.sub(g,x),x=t.add(p,y),b=t.add(T,A),x=t.mul(x,b),b=t.add(Y,l),x=t.sub(x,b),B=t.mul(k,g),b=t.mul(Z,l),B=t.add(b,B),b=t.sub(Y,B),B=t.add(Y,B),S=t.mul(b,B),Y=t.add(z,z),Y=t.add(Y,z),l=t.mul(k,l),g=t.mul(Z,g),Y=t.add(Y,l),l=t.sub(z,l),l=t.mul(k,l),g=t.add(g,l),z=t.mul(Y,g),S=t.add(S,z),z=t.mul(x,g),b=t.mul(w,b),b=t.sub(b,z),z=t.mul(w,Y),B=t.mul(x,B),B=t.add(B,z),new d(b,S,B)}subtract(f){return this.add(f.negate())}is0(){return this.equals(d.ZERO)}wNAF(f){return N.wNAFCached(this,f,d.normalizeZ)}multiplyUnsafe(f){const{endo:h,n:p}=n;et("scalar",f,W,p);const y=d.ZERO;if(f===W)return y;if(this.is0()||f===U)return this;if(!h||N.hasPrecomputes(this))return N.wNAFCachedUnsafe(this,f,d.normalizeZ);let{k1neg:q,k1:T,k2neg:A,k2:b}=h.splitScalar(f),S=y,B=y,k=this;for(;T>W||b>W;)T&U&&(S=S.add(k)),b&U&&(B=B.add(k)),k=k.double(),T>>=U,b>>=U;return q&&(S=S.negate()),A&&(B=B.negate()),B=new d(t.mul(B.px,h.beta),B.py,B.pz),S.add(B)}multiply(f){const{endo:h,n:p}=n;et("scalar",f,U,p);let y,q;if(h){const{k1neg:T,k1:A,k2neg:b,k2:S}=h.splitScalar(f);let{p:B,f:k}=this.wNAF(A),{p:Z,f:z}=this.wNAF(S);B=N.constTimeNegate(T,B),Z=N.constTimeNegate(b,Z),Z=new d(t.mul(Z.px,h.beta),Z.py,Z.pz),y=B.add(Z),q=k.add(z)}else{const{p:T,f:A}=this.wNAF(f);y=T,q=A}return d.normalizeZ([y,q])[0]}multiplyAndAddUnsafe(f,h,p){const y=d.BASE,q=(A,b)=>b===W||b===U||!A.equals(y)?A.multiplyUnsafe(b):A.multiply(b),T=q(this,h).add(q(f,p));return T.is0()?void 0:T}toAffine(f){return E(this,f)}isTorsionFree(){const{h:f,isTorsionFree:h}=n;if(f===U)return!0;if(h)return h(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:f,clearCofactor:h}=n;return f===U?this:h?h(d,this):this.multiplyUnsafe(n.h)}toRawBytes(f=!0){return ft("isCompressed",f),this.assertValidity(),i(d,this,f)}toHex(f=!0){return ft("isCompressed",f),ct(this.toRawBytes(f))}}d.BASE=new d(n.Gx,n.Gy,t.ONE),d.ZERO=new d(t.ZERO,t.ONE,t.ZERO);const v=n.nBitLength,N=Ne(d,n.endo?Math.ceil(v/2):v);return{CURVE:n,ProjectivePoint:d,normPrivateKeyToScalar:o,weierstrassEquation:a,isWithinCurveOrder:c}}function Ue(e){const n=ee(e);return mt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function _e(e){const n=Ue(e),{Fp:t,n:r}=n,i=t.BYTES+1,s=2*t.BYTES+1;function a(l){return j(l,r)}function c(l){return zt(l,r)}const{ProjectivePoint:o,normPrivateKeyToScalar:u,weierstrassEquation:E,isWithinCurveOrder:I}=Re({...n,toBytes(l,w,g){const x=w.toAffine(),O=t.toBytes(x.x),R=wt;return ft("isCompressed",g),g?R(Uint8Array.from([w.hasEvenY()?2:3]),O):R(Uint8Array.from([4]),O,t.toBytes(x.y))},fromBytes(l){const w=l.length,g=l[0],x=l.subarray(1);if(w===i&&(g===2||g===3)){const O=tt(x);if(!Et(O,U,t.ORDER))throw new Error("Point is not on curve");const R=E(O);let V;try{V=t.sqrt(R)}catch(K){const M=K instanceof Error?": "+K.message:"";throw new Error("Point is not on curve"+M)}const C=(V&U)===U;return(g&1)===1!==C&&(V=t.neg(V)),{x:O,y:V}}else if(w===s&&g===4){const O=t.fromBytes(x.subarray(0,t.BYTES)),R=t.fromBytes(x.subarray(t.BYTES,2*t.BYTES));return{x:O,y:R}}else{const O=i,R=s;throw new Error("invalid Point, expected length of "+O+", or uncompressed "+R+", got "+w)}}}),d=l=>ct(ut(l,n.nByteLength));function v(l){const w=r>>U;return l>w}function N(l){return v(l)?a(-l):l}const m=(l,w,g)=>tt(l.slice(w,g));class f{constructor(w,g,x){this.r=w,this.s=g,this.recovery=x,this.assertValidity()}static fromCompact(w){const g=n.nByteLength;return w=P("compactSignature",w,g*2),new f(m(w,0,g),m(w,g,2*g))}static fromDER(w){const{r:g,s:x}=G.toSig(P("DER",w));return new f(g,x)}assertValidity(){et("r",this.r,U,r),et("s",this.s,U,r)}addRecoveryBit(w){return new f(this.r,this.s,w)}recoverPublicKey(w){const{r:g,s:x,recovery:O}=this,R=A(P("msgHash",w));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");const V=O===2||O===3?g+n.n:g;if(V>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const C=(O&1)===0?"02":"03",F=o.fromHex(C+d(V)),K=c(V),M=a(-R*K),rt=a(x*K),X=o.BASE.multiplyAndAddUnsafe(F,M,rt);if(!X)throw new Error("point at infinify");return X.assertValidity(),X}hasHighS(){return v(this.s)}normalizeS(){return this.hasHighS()?new f(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return at(this.toDERHex())}toDERHex(){return G.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return at(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const h={isValidPrivateKey(l){try{return u(l),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const l=Qt(n.n);return Ae(n.randomBytes(l),n.n)},precompute(l=8,w=o.BASE){return w._setWindowSize(l),w.multiply(BigInt(3)),w}};function p(l,w=!0){return o.fromPrivateKey(l).toRawBytes(w)}function y(l){const w=nt(l),g=typeof l=="string",x=(w||g)&&l.length;return w?x===i||x===s:g?x===2*i||x===2*s:l instanceof o}function q(l,w,g=!0){if(y(l))throw new Error("first arg must be private key");if(!y(w))throw new Error("second arg must be public key");return o.fromHex(w).multiply(u(l)).toRawBytes(g)}const T=n.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const w=tt(l),g=l.length*8-n.nBitLength;return g>0?w>>BigInt(g):w},A=n.bits2int_modN||function(l){return a(T(l))},b=kt(n.nBitLength);function S(l){return et("num < 2^"+n.nBitLength,l,W,b),ut(l,n.nByteLength)}function B(l,w,g=k){if(["recovered","canonical"].some(D=>D in g))throw new Error("sign() legacy options not supported");const{hash:x,randomBytes:O}=n;let{lowS:R,prehash:V,extraEntropy:C}=g;R==null&&(R=!0),l=P("msgHash",l),Ht(g),V&&(l=P("prehashed msgHash",x(l)));const F=A(l),K=u(w),M=[S(K),S(F)];if(C!=null&&C!==!1){const D=C===!0?O(t.BYTES):C;M.push(P("extraEntropy",D))}const rt=wt(...M),X=F;function Bt(D){const ot=T(D);if(!I(ot))return;const vt=c(ot),lt=o.BASE.multiply(ot).toAffine(),Q=a(lt.x);if(Q===W)return;const dt=a(vt*a(X+Q*K));if(dt===W)return;let ht=(lt.x===Q?0:2)|Number(lt.y&U),it=dt;return R&&v(dt)&&(it=N(dt),ht^=1),new f(Q,it,ht)}return{seed:rt,k2sig:Bt}}const k={lowS:n.lowS,prehash:!1},Z={lowS:n.lowS,prehash:!1};function z(l,w,g=k){const{seed:x,k2sig:O}=B(l,w,g),R=n;return Gt(R.hash.outputLen,R.nByteLength,R.hmac)(x,O)}o.BASE._setWindowSize(8);function Y(l,w,g,x=Z){var ht;const O=l;w=P("msgHash",w),g=P("publicKey",g);const{lowS:R,prehash:V,format:C}=x;if(Ht(x),"strict"in x)throw new Error("options.strict was renamed to lowS");if(C!==void 0&&C!=="compact"&&C!=="der")throw new Error("format must be compact or der");const F=typeof O=="string"||nt(O),K=!F&&!C&&typeof O=="object"&&O!==null&&typeof O.r=="bigint"&&typeof O.s=="bigint";if(!F&&!K)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let M,rt;try{if(K&&(M=new f(O.r,O.s)),F){try{C!=="compact"&&(M=f.fromDER(O))}catch(it){if(!(it instanceof G.Err))throw it}!M&&C!=="der"&&(M=f.fromCompact(O))}rt=o.fromHex(g)}catch{return!1}if(!M||R&&M.hasHighS())return!1;V&&(w=n.hash(w));const{r:X,s:Bt}=M,D=A(w),ot=c(Bt),vt=a(D*ot),lt=a(X*ot),Q=(ht=o.BASE.multiplyAndAddUnsafe(rt,vt,lt))==null?void 0:ht.toAffine();return Q?a(Q.x)===X:!1}return{CURVE:n,getPublicKey:p,getSharedSecret:q,sign:z,verify:Y,ProjectivePoint:o,Signature:f,utils:h}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ke(e){return{hash:e,hmac:(n,...t)=>se(e,n,oe(...t)),randomBytes:re}}function Ce(e,n){const t=r=>_e({...e,...ke(r)});return{...t(n),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ne=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Pt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ve=BigInt(1),Zt=BigInt(2),Ft=(e,n)=>(e+n/Zt)/n;function Me(e){const n=ne,t=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),a=BigInt(23),c=BigInt(44),o=BigInt(88),u=e*e*e%n,E=u*u*e%n,I=H(E,t,n)*E%n,d=H(I,t,n)*E%n,v=H(d,Zt,n)*u%n,N=H(v,i,n)*v%n,m=H(N,s,n)*N%n,f=H(m,c,n)*m%n,h=H(f,o,n)*f%n,p=H(h,c,n)*m%n,y=H(p,t,n)*E%n,q=H(y,a,n)*N%n,T=H(q,r,n)*u%n,A=H(T,Zt,n);if(!Lt.eql(Lt.sqr(A),e))throw new Error("Cannot find square root");return A}const Lt=Xt(ne,void 0,void 0,{sqrt:Me}),je=Ce({a:BigInt(0),b:BigInt(7),Fp:Lt,n:Pt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const n=Pt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Ve*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=t,a=BigInt("0x100000000000000000000000000000000"),c=Ft(s*e,n),o=Ft(-r*e,n);let u=j(e-c*t-o*i,n),E=j(-c*r-o*s,n);const I=u>a,d=E>a;if(I&&(u=n-u),d&&(E=n-E),u>a||E>a)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:I,k1:u,k2neg:d,k2:E}}}},ie);BigInt(0);je.ProjectivePoint;export{je as secp256k1};
